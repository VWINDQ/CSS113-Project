# CSS113 Project

---

### 1. DFS (Depth-First Search) - การค้นหาในแนวลึก

คอนเซปต์: "ไปให้สุดแล้วค่อยกลับมา"

DFS จะเลือกเส้นทางหนึ่งแล้วเดินลุยไปข้างหน้าเรื่อยๆ จนกว่าจะเจอทางตัน (Dead end) หรือเจอเป้าหมาย ถ้าเจอทางตัน มันจะถอยหลัง (Backtrack) กลับมายังทางแยกก่อนหน้า แล้วลองไปอีกเส้นทางหนึ่ง

- **หลักการ:** ใช้ **Stack** (เข้าทีหลัง ออกก่อน)
- **เปรียบเทียบ:** เหมือนการเดินเขาวงกต ที่คุณเอามือแตะกำแพงซ้ายแล้วเดินไปเรื่อยๆ จนสุดทาง ถ้าตันก็เดินย้อนกลับมาทางแยกเดิมแล้วลองไปทางขวาต่อ
- **ข้อดี:** ใช้หน่วยความจำน้อยกว่าถ้าต้นไม้ลึกมาก
- **ข้อเสีย:** อาจไม่ใช่เส้นทางที่สั้นที่สุด อาจหลงไปในเส้นทางที่ลึกมากๆ แบบไร้ประโยชน์

### 2. BFS (Breadth-First Search) - การค้นหาในแนวกว้าง

คอนเซปต์: "กระจายออกเป็นวงกลม"

BFS จะสำรวจเพื่อนบ้านที่อยู่ติดกันทั้งหมดก่อน (ชั้นที่ 1) แล้วค่อยขยับไปสำรวจเพื่อนของเพื่อนบ้าน (ชั้นที่ 2) ทำแบบนี้ขยายวงออกไปเรื่อยๆ

- **หลักการ:** ใช้ **Queue** (เข้าก่อน ออกก่อน)
- **เปรียบเทียบ:** เหมือนการโยนหินลงน้ำ แล้วคลื่นกระจายเป็นวงกลมออกจากจุดศูนย์กลาง หรือเหมือนไฟไหม้ป่าที่ลามออกไปทุกทิศทางพร้อมๆ กัน
- **ข้อดี:** รับประกันว่าจะเจอ **เส้นทางที่สั้นที่สุด** (ในกราฟที่ไม่มีน้ำหนัก หรือน้ำหนักเท่ากันหมด)
- **ข้อเสีย:** กินหน่วยความจำเยอะ เพราะต้องจำโหนดในชั้นปัจจุบันทั้งหมด

---

### 3. Dijkstra’s Algorithm - ไดจ์สตรา

คอนเซปต์: "เลือกทางที่ถูกที่สุดเสมอ"

Dijkstra พัฒนามาจาก BFS แต่ฉลาดกว่าตรงที่มันรองรับ "น้ำหนัก" (Weight) (เช่น ระยะทาง, ค่ารถ, เวลา) มันจะไม่เดินสุ่มสี่สุ่มห้า แต่มันจะคำนวณว่า จากจุดเริ่มต้น ไปยังโหนดข้างเคียง เส้นทางไหนใช้ "ต้นทุน" น้อยที่สุด แล้วเลือกไปเส้นนั้นก่อน

- **หลักการ:** ใช้ **Priority Queue** (คิวลำดับความสำคัญ - เก็บค่าที่น้อยที่สุดไว้บนสุด)
- **เปรียบเทียบ:** เหมือน Google Maps เวลาหาทางกลับบ้าน มันไม่ได้ดูแค่ว่าถนนเส้นไหนสั้นที่สุด (ระยะทาง) แต่อาจจะดูรถติด (เวลา) ด้วย โดยมันจะพยายามหาผลรวมของความลำบากที่น้อยที่สุด
- **ข้อควรระวัง:** ใช้ไม่ได้กับกราฟที่มีน้ำหนักติดลบ (Negative Weight)

[รูปภาพDijkstra algorithm shortest path diagram](https://encrypted-tbn0.gstatic.com/licensed-image?q=tbn:ANd9GcRX2ZuQuRzZz1m9OEpXWANZgJsT_tYaLXy9vgQULM78yebWEvfMABoowuYjnWrGdJTpwZFPWnBXCM1Py_vXlwsODYS-LbzwTRm82jp_5BlyNckfe8w)

Shutterstock

---

### 4. MST (Minimum Spanning Tree)

MST ไม่ได้หาเส้นทางจาก A ไป B แต่มีเป้าหมายคือ **"เชื่อมทุกจุดเข้าด้วยกัน โดยใช้สายไฟสั้นที่สุดและห้ามวนลูป"**

### A. Kruskal’s Algorithm

คอนเซปต์: "เลือกเส้นที่สั้นที่สุดในโลกก่อน"

Kruskal มองภาพรวมทั้งกราฟ มันจะเรียงลำดับเส้นเชื่อม (Edge) ทั้งหมดจากน้อยไปมาก แล้วหยิบเส้นที่สั้นที่สุดมาต่อกัน ถ้าเส้นไหนหยิบมาแล้วทำให้เกิดวงกลม (Loop/Cycle) ก็จะทิ้งไป ทำไปเรื่อยๆ จนครบทุกจุด

- **หลักการ:** เรียงลำดับ Edge + ตรวจสอบ Cycle (ใช้ Union-Find)
- **เปรียบเทียบ:** เหมือนรัฐบาลจะสร้างถนนเชื่อมทุกจังหวัด โดยเริ่มสร้างจากถนนเส้นที่ถูกที่สุดในประเทศก่อน ไม่ว่าจะอยู่ที่ไหน แล้วค่อยๆ สร้างเส้นที่แพงขึ้น จนกว่าทุกจังหวัดจะเดินทางหากันได้

### B. Prim’s Algorithm

คอนเซปต์: "ค่อยๆ ขยายอาณาเขต"

Prim จะเริ่มจากจุดหนึ่ง (จุดไหนก็ได้) แล้วดูว่าจากอาณาเขตที่เรายึดได้แล้ว มีเส้นทางไหนที่เชื่อมออกไปข้างนอกที่ "ถูกที่สุด" บ้าง ก็เลือกเส้นนั้นแล้วผนวกเมืองนั้นเข้ามาในอาณาเขต ทำซ้ำไปเรื่อยๆ

- **หลักการ:** ใช้ Priority Queue เก็บเส้นเชื่อมที่ต่อกับโหนดที่เยี่ยมแล้ว
- **เปรียบเทียบ:** เหมือนเชื้อราที่ค่อยๆ ลาม หรืออาณาจักรที่ค่อยๆ ตีเมืองชายแดนที่ใกล้มือและตียกง่ายที่สุดไปเรื่อยๆ จนยึดได้ทั้งทวีป

### สรุปสั้นๆ

- **DFS:** ลุยลึกไปให้สุดซอย (เหมาะหาว่ามีทางไปไหม)
- **BFS:** ค่อยๆ ลามเป็นวงกลม (เหมาะหาทางสั้นสุดในกราฟปกติ)
- **Dijkstra:** เลือกทางที่ "คุ้มค่า" ที่สุด (เหมาะหาทางสั้นสุดในกราฟมีระยะทาง)
- **Kruskal/Prim:** เชื่อมทุกจุดให้ครบด้วยงบประหยัดสุด (วางโครงข่าย)
